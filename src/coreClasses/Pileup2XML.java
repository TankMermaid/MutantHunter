package coreClasses;

import java.io.File;
import java.io.IOException;
import java.util.Hashtable;
import java.util.concurrent.ExecutionException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

import nlr_parser.MastMotifHitList;
import nlr_parser.NLRParser;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.OptionBuilder;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;
import org.xml.sax.SAXException;

public class Pileup2XML {

	
	
	/**
	 * 
	 * @param args
	 */
	public static void main(String[] args){
		
		
		
		
		Options options = new Options();
		options.addOption( OptionBuilder.withLongOpt( "inputPileup")
										.withDescription("a pileup File generated by samtools mpileup containing the mapping of rawdata against wt assembly.")
										.isRequired()
										.hasArg()
										.withArgName("file.mpileup")
										.create('i'));
		options.addOption( OptionBuilder.withLongOpt( "outputXML")
										.withDescription("The output file in xml format")
										.hasArg()
										.withArgName("output.xml")
										.create('o'));
		options.addOption( OptionBuilder.withLongOpt( "isWildtype")
										.withDescription("set this option if the pileup is from the wildtype mapping")
										.create('w'));
		
		
		options.addOption(OptionBuilder.withLongOpt("blast")
										.withDescription("Select The Regions by Blast")
										.hasArg()
										.withArgName("blast.xml")
										.create('b'));
		options.addOption(OptionBuilder.withLongOpt("mastbackup")
										.withDescription("Set Contig List from backed up mast call")
										.hasArg()
										.withArgName("mast.xml")
										.create('m'));
		options.addOption(OptionBuilder.withLongOpt("minCoverage")
										.withDescription("Minimum coverage to report a SNP")
										.hasArg()
										.withArgName("minCov")
										.create('c'));
		
				
		options.addOption(OptionBuilder.withLongOpt("sequence")
										.withDescription("The DNA sequence of the wildtype contig")
										.hasArg()
										.withArgName("sequence.fasta")
										.create('s'));
		options.addOption(OptionBuilder.withLongOpt("mast")
										.withDescription("Output is general feature format instead of tab separated")
										.hasArg()
										.withArgName("mast")
										.create('y'));
		options.addOption(OptionBuilder.withLongOpt("meme")
										.withDescription("Output is general feature format instead of tab separated")
										.hasArg()
										.withArgName("meme.xml")
										.create('x'));
		options.addOption(OptionBuilder.withLongOpt("num_threads")
										.withDescription("Number of Threads for the Mast call. Default 2. Argument is useless without -s, -x and -y")
										.hasArg()
										.create('t'));
		
		
		CommandLineParser parser = new PosixParser();
		
		try{
			CommandLine line = parser.parse( options, args );
			
			
			
			File inputPileupFile = new File(line.getOptionValue('i'));
			
			File outputXMLFile = new File( inputPileupFile.getParentFile(), inputPileupFile.getName().split("\\.pileup")[0]+".xml");
			
			if(line.hasOption('o')){
				outputXMLFile = new File(line.getOptionValue('o'));
			}
			
			
			boolean isWildtype = false;
			if(line.hasOption('w')){
				isWildtype = true;
			}
			
			int minCoverage = 5;
			if(line.hasOption('c')){
				try{
					minCoverage = Integer.parseInt(line.getOptionValue('c'));
				}catch (NumberFormatException e){System.err.println("Warning: wrong input value for -c. This needs to be in int. Default is used.");};	
			}
			
			
			MutantHunter hunter;
			//option1 There is a mast backup file
			if( line.hasOption('m')){
				NLRParser nlrparser = new NLRParser(new File(line.getOptionValue('m')));
				
				hunter = new MutantHunter();
				hunter.setNLRContigList(nlrparser.getMastMotifHitLists());
				
			}else if( line.hasOption('s') && line.hasOption('y') && line.hasOption('x') ){
				int numThreads = 2;
				if( line.hasOption('t')){
					numThreads = Integer.parseInt(line.getOptionValue('t'));
				}
				File sequenceFile = new File(line.getOptionValue('s'));
				File mastExe = new File(line.getOptionValue('y'));
				File memeXML = new File(line.getOptionValue('x'));
				Hashtable<String, MastMotifHitList > nlrs = new NLRParser(sequenceFile, mastExe, memeXML, numThreads, 1000, 1E-5).getMastMotifHitLists();
				hunter = new MutantHunter();
				hunter.setNLRContigList(nlrs);
				hunter.addSequences(sequenceFile);
			}else{
				throw new ParseException("Missing Input. Either provide NLR-Parser result in xml format or provide the sequence file, the mast executable and the meme.xml for NLR motifs.");
			}
			
			
			
			
			if( line.hasOption('b')){
				hunter.addRegions(new File(line.getOptionValue('b')), 10, true);
			}
			
			String mutantLine = inputPileupFile.getName();
			if( isWildtype){
				mutantLine = MutantHunter.wildtype;
			}
			hunter.readPileupFile(mutantLine, inputPileupFile, minCoverage);
			
			
			hunter.exportToXML(outputXMLFile);
			
		}catch(IOException e){
			e.printStackTrace();
		}
		catch(ParseException e){
			System.out.println("Parsing Failed: ");
			e.printStackTrace();
			HelpFormatter formatter = new HelpFormatter();
	        formatter.printHelp( "SequenceTools", options );
		}
		catch(SAXException e){
			e.printStackTrace();
		}
		catch(ParserConfigurationException e){
			e.printStackTrace();
		}
		catch(InterruptedException e){
			e.printStackTrace();
		}
		catch(ExecutionException e){
			e.printStackTrace();
		}
		catch (TransformerException e){
			e.printStackTrace();
		}
		
	}
	
	
	
	
	
	
}
